// The takes and return is what takes or return from-to stack
/* Interface */
#define function mintHorse() nonpayable returns()
#define function feedHorse(uint256) nonpayable returns()
#define function isHappyHorse(uint256) view returns(bool)
#define function horseIdToFedTimeStamp(uint256) view returns(uint256)
#define function HORSE_HAPPY_IF_FED_WITHIN() view returns(uint256)

#define macro FEED_HORSE() = takes(0) returns(0) {
    timestamp                   // [timestamp]
    0x04 clldataload            // [horseId, timestamp] // Give me all the data after the first 4 bytes
    // sstore the timestamp with the horseId key
}

#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xe0 shr          // [func_selector]

    dup1 __FUNC_SIG(mintHorse) eq mintHorse jumpi
    dup1 __FUNC_SIG(feedHorse) eq feedHorse jumpi
    dup1 __FUNC_SIG(isHappyHorse) eq isHappyHorse jumpi
    dup1 __FUNC_SIG(horseIdToFedTimeStamp) eq horseIdToFedTimeStamp jumpi
    dup1 __FUNC_SIG(HORSE_HAPPY_IF_FED_WITHIN) eq horseHappyFedWithin jumpi

    mintHorse:
        MINT_HORSE()    
    feedHorse:
        FEED_HORSE()
    isHappyHorse:
        IS_HAPPY_HORSE()

    horseIdToFedTimeStamp:
        HORSE_ID_TO_FED_TIMESTAMP()

    horseHappyFedWithin:
        HORSE_HAPPY_IF_FED_WITHIN()
}